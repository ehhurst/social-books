from flask import Flask, request, jsonify
from flask_cors import CORS
from book_api import fetch_books_from_api, parse_books, get_book
import sqlite3
import datetime
from flask_jwt_extended import JWTManager
from flask_jwt_extended import jwt_required, get_jwt_identity
from auth import auth, bcrypt
import json
import os


DATABASE = "./social-books.db" # This is the .db file generated by Yoon and Connor

app = Flask(__name__)
CORS(app)  # Allow frontend to communicate with backend

bcrypt.init_app(app)  # Initialize bcrypt for password hashing

# Initialize JWT here
app.config["JWT_SECRET_KEY"] = os.getenv("JWT_SECRET_KEY", "fallback-secret-key")  # Use env variable
jwt = JWTManager(app)

# Register the authentication blueprint
app.register_blueprint(auth, url_prefix="/auth")

bcrypt.init_app(app)  # Initialize bcrypt for password hashing

@app.route("/", methods=["GET"])
def home():
	return jsonify({"message": "Flask API is running"}), 200


@app.route('/book/<string:work_id>', methods=['GET'])
def book(work_id):
    """
    Flask route to handle book get requests.
    
    Returns:
        Response: JSON response containing book details or an error message.
    """
    # Use the get_book function to get the search results
    book = get_book(work_id=work_id)

    return jsonify(book)

# Author Nithin -- reference for clarification.
@app.route('/search', methods=['GET'])
def search_books():
    """
    Flask route to handle book search requests.
    
    Returns:
        Response: JSON response containing search results or an error message.
    """
    print("PARAM : ", request)
    query = request.args.get('q')
    title = request.args.get('title')
    author = request.args.get('author')
    subject = request.args.get('subject')
    # users = request.args.get('accounts')
    # contests = request.args.get('contests')
    # reviews = request.args.get('reviews')
    limit = request.args.get('limit')

    if not (query or title or author or subject):
        return jsonify({'error': 'Missing search parameter'}), 400

    # Use the fetch_books_from_api function to get the search results
    if (query or title or author or subject):
        books = fetch_books_from_api(query=query, title=title, author=author, subject=subject, limit=limit)
        return jsonify(books)
    # if (users):
    #     print('here')
    #     result = fetch_users(users)
    #     print(result)
    #     return jsonify(result)
    # if (contests):
    #     result = fetch_contests(contests)
    #     return jsonify(result)
    # if (reviews):
    #     result = fetch_reviews(reviews)
    #     print("reviews: ", result)
    #     return jsonify(result)


    

# @app.route('/api/data') <-- re-enable this line if things break, shouldn't need it
def db_connect():
    """ Opens a connection to the database. Hosted at 127.0.0.1 IP (localhost) """
    try:
        # Connect to the sqlite database. Modify the path at the top.
        conn = sqlite3.connect(DATABASE)
        print(f"Connection to database {DATABASE} successful.")
    except sqlite3.Error as error:
        print(f"ERROR CONNECTING {DATABASE}: errcode {error}")
    
    conn.row_factory = sqlite3.Row

    return conn



# gets all user data for the reader profile page 
@app.route("/user", methods=["GET"])
@jwt_required()
def return_user_data():
    """ Returns all user info as a json object. 
    Not sure of the format here, might need more work. """
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")

    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    conn = db_connect()
    query = """
        SELECT username, first_name, last_name, goal FROM users
        WHERE users.username = ?
    """
    # executes this query, fetches one user's data
    user_data = conn.execute(query, (current_user,)).fetchone()
    conn.close()

    # Return the user info as a json dictionary, should return whole tuple info
    if user_data:
        return jsonify(dict(user_data))
    else:
        return jsonify({"error": f"user data not found"}), 404 #NOT FOUND






 
# need to integrate to use those in auth.py, remove <string:username> from url
# NOTE: does this need to insert other information also?
# ?
# ?
# ?
# ?
# @app.route("/users/add/<string:username>", methods=["POST"])
# def add_user(username):
#     """ Adds a user to the database """

#     if not username:
#         return jsonify({"error": "no username given"}), 400 #BAD REQUEST
    
#     conn = db_connect()
#     cursor = conn.cursor()

#     # Tries to insert, if a user_id already exists sqlite3 should throw an integrity error
#     # Later on we want to change this from an error to some sort of front-end behavior
#     # That's for further on this week
#     try:
#         query = "INSERT INTO users (username) VALUES (?)"
#         cursor.execute(query, (username,))
#         conn.commit()
#     except sqlite3.IntegrityError:
#         conn.close()
#         return jsonify({"error": f"user {username} already exists"}), 409 #CONFLICT
    
#     conn.close()

#     return jsonify({"message": f"user {username} added successfully"}), 201 #CREATED


@app.route("/users/delete", methods=["DELETE"])
@jwt_required()
def delete_user():
    """ Removes a user from the database """
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")
        
    if not token:
        return jsonify({"error": "Missing authorization token"}), 401

    conn = db_connect()
    cursor = conn.cursor()
    
    if not current_user:
        return jsonify({"error": "no username given for deletion"}), 400 #BAD_REQUEST
    
    query = "SELECT username FROM users WHERE username = ?"
    cursor.execute(query, (current_user,))
    user = cursor.fetchone()

    if not user:
        conn.close()
        return jsonify({"error": "user not found for deletion from user table"}), 404 #NOT FOUND

    deletion_query = "DELETE FROM users WHERE username = ?"
    cursor.execute(deletion_query, (current_user,))
    conn.commit()
    conn.close()

    return jsonify({"message": f"user {current_user} deleted successfully from users table"}), 200 #OK




@app.route("/goals", methods=["PUT"])
@jwt_required()
def set_goal():
    current_user = get_jwt_identity()
    token = request.headers.get("Authorization")

    if not token:
        return jsonify({"Error: Missing authorization token"}), 401
    
    reading_goal = request.json

    if not reading_goal:
        return jsonify({"error": "No reading goal provided"}), 400 #BAD REQUEST
    if (reading_goal < 0):
        return jsonify({"error": "Reading goal must be >= 0"}), 412 #PRECONDITION FAILED

    conn = db_connect()
    cursor = conn.cursor()

    cursor.execute("SELECT username FROM users WHERE username = ?", (current_user,))
    user = cursor.fetchone()

    if not user:
        conn.close()
        return jsonify({"error": "user not found."}), 404 #NOT FOUND
    
    try:
        query ="""UPDATE users
                SET goal = ?
                WHERE users.username = ?"""
        cursor.execute(query, (reading_goal, current_user))
        conn.commit()

    except sqlite3.Error as error:
        conn.close()
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR
    
    conn.close()
    return jsonify({"message": "Successfully updated reading goal", "user_id" : current_user, "goal" : reading_goal}), 201 #CREATED



@app.route('/<string:username>/goals', methods=["GET"])
def get_goals(username):
    conn = db_connect()
    cursor = conn.cursor()

    query = "SELECT goal FROM users WHERE username = ?"
    cursor.execute(query, (username,))
    goal = cursor.fetchone()
    print(username, goal[0])
    
    return jsonify(goal[0]), 200


@app.route("/reviews", methods=["POST"])
@jwt_required()
def add_review():
    """ Adds a review. Content of the review needs to be in the POST query.
     So far this only updates the reviews table. Maybe update other tables? Probably not. """
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")
        
    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM users WHERE username = ?" # replaced profile_id with uesrname
    reviewer = cursor.execute(find_user_query, (current_user,)).fetchone()

    if not reviewer:
        conn.close()
        return jsonify({"error":f"user {current_user} not found, not updating reviews"}), 400 #BAD REQUEST
    
    r_metadata = request.json
    work_ID = r_metadata.get("work_id")
    rating = r_metadata.get("star_rating")
    liked = r_metadata.get("liked")
    text = r_metadata.get("review_text")
    
    from profanity_filter import is_profane
        
    profanity_list = is_profane(text)
    
    if profanity_list:
        conn.close()
        return jsonify({"error": f"Profanity detected in review: {profanity_list}"}), 412
    

    if not work_ID or not rating or not text:
        conn.close()
        return jsonify({"error": "work_ID, rating, or text is bad"}), 400 #BAD REQUEST
    
    if not (1 <= rating <= 5):
        conn.close()
        return jsonify({"error": "rating is out of 1-5 range"}), 412 #PRECONDITION FAILED
    
    try:
        query = "INSERT INTO reviews (username, work_ID, star_rating, liked, review_text) VALUES (?, ?, ?, ?, ?)"
        cursor.execute(query, (current_user, work_ID, rating, liked, text))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR
    
    conn.close()
    return jsonify({"message": "Review added successfully", "user_id" : current_user, "work_ID" : work_ID}), 201 #CREATED


@app.route("/reviews/<string:review_id>", methods=["PUT"])
@jwt_required()
def update_review(review_id):
    """ Edits a review. Content of the review needs to be in the PUT query.
     So far this only updates the reviews table. Maybe update other tables? Probably not. """
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")

    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM users WHERE username = ?"
    reviewer = cursor.execute(find_user_query, (current_user,))

    if not reviewer:
        conn.close()
        return jsonify({"error":f"user {current_user} not found, not updating reviews"}), 400 #BAD REQUEST 
    
    find_review_query = "SELECT review_id FROM reviews WHERE review_id = ?"
    cursor.execute(find_review_query, (review_id,))
    review = cursor.fetchone()

    if not review:
        conn.close()
        return jsonify({"error":f"review {review_id} not found, not updating reviews"}), 400 #BAD REQUEST
    
    r_metadata = request.json
    work_ID = r_metadata.get("work_id")
    rating = r_metadata.get("star_rating")
    liked = r_metadata.get("liked")
    text = r_metadata.get("review_text")
    
    from profanity_filter import is_profane
        
    profanity_list = is_profane(text)
    
    if profanity_list:
        conn.close()
        return jsonify({"error": f"Profanity detected in review: {profanity_list}"}), 412

    if not work_ID or not rating or not text:
        conn.close()
        return jsonify({"error": "work_ID, rating, or text is bad"}), 400 #BAD REQUEST
    
    if not (1 <= rating <= 5):
        conn.close()
        return jsonify({"error": "rating is out of 1-5 range"}), 412 #PRECONDITION FAILED
    
    try:
        query ="""
        UPDATE reviews
        SET star_rating = ? , liked = ? , review_text = ?
        WHERE reviews.review_id = ?
    """
        # query = "UPDATE reviews " \
        # "SET (username, work_ID, star_rating, liked, review_text) SET (?, ?, ?, ?, ?) WHERE review_id={review_id}"
        cursor.execute(query, (rating, liked, text, review_id))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR
    
    conn.close()
    return jsonify({"message": "Review edited successfully", "user_id" : current_user, "review_id" : review_id, "work_ID" : work_ID}), 201 #CREATE

# Delete a review
@app.route("/reviews/<string:review_id>", methods=["DELETE"])
def remove_review(review_id):
    """ This removes a review with a specific ID. """
    conn = db_connect()
    cursor = conn.cursor()

    find_review_query = "SELECT review_id FROM reviews WHERE review_id = ?"
    cursor.execute(find_review_query, (review_id,))
    review = cursor.fetchone()

    if not review:
        conn.close()
        return jsonify({"error":f"review {review_id} not found, not updating reviews"}), 400 #BAD REQUEST
    
    deletion_query = "DELETE FROM reviews WHERE review_id = ?"
    cursor.execute(deletion_query, (review_id,))
    conn.commit()
    conn.close()

    return jsonify({"message": f"review {review_id} deleted successfully"}), 200 #OK


# GET all reviews associated with a book
@app.route("/books/<string:work_ID>/reviews", methods=["GET"])
def return_review_data(work_ID):
    # check for valid work ID
    if work_ID == '' or work_ID == "undefined":
        return jsonify({"error": f"book {work_ID} not found or invalid"}), 404 #NOT FOUND

    """ Returns the book's reviews and review score average as a JSON object. """
    conn = db_connect()
    query = """
        SELECT * FROM reviews
        WHERE reviews.work_id = ?
    """

    # NOTE: Learned how to do the following 4 lines with ChatGPT prompt: "teach me how to create 
    # a list of dictionaries, with each list corresponding to a sqlite row, and each 
    # dictionary corresponding to a sqlite column name and its value in that row"
    cursor = conn.execute(query, (work_ID,))
    rows = cursor.fetchall()
    columns = [description[0] for description in cursor.description]
    reviews = [dict(zip(columns, row)) for row in rows]

    # default return value for no reviews
    if len(reviews) == 0:
        avg = -1
    else:
        # Get average review score
        query2 = """
        SELECT ROUND(AVG(star_rating), 1) FROM reviews
        WHERE reviews.work_id = ?
        """
        cursor = conn.execute(query2, (work_ID,))
        singleRow = cursor.fetchone()
        avg = (singleRow[0])


    reviews_data = {
            'work_id': work_ID, 
            'avg_rating': avg, 
            'reviews_list': reviews
    }
    conn.close()

    return jsonify(reviews_data)


# GET all reviews associated with a user
@app.route("/user/reviews", methods=["GET"])
@jwt_required()
def get_user_reviews():
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")
    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    conn = db_connect()
    query = """
        SELECT * FROM reviews
        WHERE reviews.username = ?
    """
    # NOTE: Learned how to do the following 4 lines with ChatGPT prompt: "teach me how to create 
    # a list of dictionaries, with each list corresponding to a sqlite row, and each 
    # dictionary corresponding to a sqlite column name and its value in that row"
    cursor = conn.execute(query, (current_user,))
    rows = cursor.fetchall()
    columns = [description[0] for description in cursor.description]
    reviews = [dict(zip(columns, row)) for row in rows]
    conn.close()


    # Return the book review info as a json dictionary, should return whole tuple info
    if reviews:
        return jsonify(reviews)
    else:
        return jsonify([])
 


@app.route("/follow", methods=["POST"])
@jwt_required()
def add_follower():
    """ Adds a follower to the current user's followers list. 
    User to follow is specified in JSON.
    """
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")

    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM users WHERE username = ?"
    user = cursor.execute(find_user_query, (current_user,))

    if not user:
        conn.close()
        return jsonify({"error":f"user {user} not found, not updating followers"}), 400 #BAD REQUEST
    
    user_to_follow = request.json

    if not user_to_follow:
        conn.close()
        return jsonify({"error": "bad follower"}), 400 #BAD REQUEST
        
    try:
        query = "INSERT INTO followers (follower_username, follows_username) VALUES (?, ?)"
        cursor.execute(query, (current_user, user_to_follow,))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR
    
    conn.close()
    return jsonify({"message": f"Follower added successfully. User {current_user} is now following {user_to_follow}"}), 201 #CREATED



@app.route("/<string:username>/followers", methods=["GET"])
def get_followers(username):
    """ Return a list of a user's followers. Returns empty list no followers """
    conn = db_connect()
    
    usercheck = """
        SELECT COUNT(username)
        FROM users
        WHERE username = ?
    """

    # check if user exists
    checkCursor = conn.execute(usercheck, (username,))
    singleRow = checkCursor.fetchone()
    count = int(singleRow[0])
    if count == 0:
        return jsonify({"error": f"user {username} does not exist"}), 404 # NOT FOUND
    
    query = """
        SELECT follower_username FROM followers
        WHERE followers.follows_username = ?
    """

    cursor = conn.execute(query, (username,))
    rows = cursor.fetchall()

    # Next 5 lines written with help of ChatGPT prompt: 
    # i want to create a list of dictionaries, where the dictionaries
    # are enumerations of the values of the sqlite3 rows. 
    # like 1, friendname
    followers = [
        {"username": row[0]}
        for index, row in enumerate(rows)
    ]
    result = followers

    conn.close()

    return jsonify(result)

@app.route("/<string:username>/following", methods=["GET"])
def get_following(username):
    """ Return a list of users that are following this user. 
    Returns empty list if no followers """
    conn = db_connect()
    
    usercheck = """
        SELECT COUNT(username)
        FROM users
        WHERE username = ?
    """

    # check if user exists
    checkCursor = conn.execute(usercheck, (username,))
    singleRow = checkCursor.fetchone()
    count = int(singleRow[0])
    if count == 0:
        return jsonify({"error": f"user {username} does not exist"}), 404 # NOT FOUND
    
    query = """
        SELECT follows_username FROM followers
        WHERE followers.follower_username = ? 
    """

    cursor = conn.execute(query, (username,))
    rows = cursor.fetchall()

    # Next 5 lines written with help of ChatGPT prompt: 
    # i want to create a list of dictionaries, where the dictionaries
    # are enumerations of the values of the sqlite3 rows. 
    # like 1, friendname
    followers = [
        {"username": row[0]}
        for index, row in enumerate(rows)
    ]
    result = followers

    conn.close()

    return jsonify(result)

@app.route("/contest/create", methods=["POST"])
@jwt_required()
def create_contest():
    """ Creates a contest with the provided name """
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")
        
    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM users WHERE username = ?" # replaced profile_id with uesrname
    organizer = cursor.execute(find_user_query, (current_user,)).fetchone()

    if not organizer:
        conn.close()
        return jsonify({"error":f"user {current_user} not found, not creating contest"}), 400 #BAD REQUEST
    
    r_metadata = request.json
    contest_name = r_metadata['contest_name']
    work_ids = r_metadata['work_ids'] # array of work_ids
    end_date = r_metadata['end_date'] # end date, format YYYY-MM-DD
    num_works = len(work_ids)

    if not contest_name:
        conn.close()
        return jsonify({"error": "Null contest_name"}), 400 #BAD REQUEST
    if not end_date:
        conn.close()
        return jsonify({"error": "Null end_date"}), 400 #BAD REQUEST
    if num_works < 1:
        conn.close()
        return jsonify({"error": "num_works < 1"}), 400 #BAD REQUEST
    
    try:
        query = """
        INSERT INTO contests (contest_name, book_count, end_date) values (?, ?, ?)
        """
        cursor.execute(query, (contest_name, num_works, end_date))
        conn.commit()
    except sqlite3.Error as e:
        return jsonify({"error": f"contest_failure {e}"}), 500 #INTERNAL SERVER ERROR
    
    #ADD WORKS AND CREATOR HERE

    for work in work_ids:
        
        try:
            query = "INSERT INTO contest_books (contest_name, work_id) VALUES (?, ?)"
            cursor.execute(query, (contest_name, work))
            conn.commit()
        except sqlite3.Error as e:
            return jsonify({"error": f"workfailure_{work} {e}"}), 500 #INTERNAL SERVER ERROR
        
    try:
        query = "INSERT INTO contest_participants (contest_name, username, books_read, perm_lvl) VALUES (?, ?, ?, ?)"
        cursor.execute(query, (contest_name, organizer[0], 0, 0))
        conn.commit()
    except sqlite3.Error as e:
        conn.close()
        return jsonify({"error":f"contestowner_failure{e}"}), 500 #INTERNAL SERVER ERROR
    
    conn.close()

    return jsonify({"message": f"contest {contest_name} successfully created"}), 201 #CREATED

@app.route("/contest/<string:contest_name>/deadline", methods=["GET"])
def contest_deadline(contest_name):
    conn = db_connect()
    cursor = conn.cursor()

    current_time = str(datetime.datetime.now()).split(" ")[0] # Takes only YYYY-MM-DD from YYYY-MM-DD HH:MM:SS.MS string
    query = """
    SELECT end_date FROM contests WHERE contest_name = ?
    """
    cursor.execute(query, (contest_name,))
    deadline_time = cursor.fetchone()

    dt_curr = datetime.striptime(current_time, "%Y-%m-%d")
    dt_dead = datetime.striptime(deadline_time, "%Y-%m-%d")

    conn.close()

    if dt_curr < dt_dead:
        return jsonify({"complete": "True"})
    else:
        return jsonify({"complete": "False"})
    
@app.route("/contest/<string:contest_name>/fetch", methods=["GET"])
@jwt_required()
def contest_checklist(contest_name):
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")
        
    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM users WHERE username = ?" # replaced profile_id with uesrname
    competitor = cursor.execute(find_user_query, (current_user,)).fetchone()["username"]

    if not competitor:
        conn.close()
        return jsonify({"error":f"user {current_user} not found, not fetching checklist"}), 400 #BAD REQUEST
    

    query = "SELECT work_id FROM contest_books_read WHERE username = ? AND contest_name = ?"
    cursor.execute(query, (competitor, contest_name))
    readbooks = [work_id[0] for work_id in cursor.fetchall()] # Should return just the string out of each tuple in the result...
    # [("workname"), ("workname1"), ...] <-- double check if needed. Should work out the box

    conn.close()
    return jsonify({"readbooks":readbooks}), 200 # OK

@app.route("/contest/mark/<string:contest_name>/<string:work_id>", methods=["POST"])
@jwt_required()
def contest_markdone(contest_name, work_id):
    current_user = get_jwt_identity()  # Get the current user's identity from the JWT
    token = request.headers.get("Authorization")
        
    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM users WHERE username = ?" # replaced profile_id with uesrname
    competitor = cursor.execute(find_user_query, (current_user,)).fetchone()["username"]

    if not competitor:
        conn.close()
        return jsonify({"error":f"user {current_user} not found, not updating contest books read"}), 400 #BAD REQUEST

    if not contest_name:
        conn.close()
        return jsonify({"error":"No contest_name"}), 400 #BAD REQUEST
    
    if not work_id:
        conn.close()
        return jsonify({"error":"No work_id"}), 400 #BAD REQUEST
        
    query = "SELECT work_id FROM contest_books_read WHERE username = ? AND work_id = ? AND contest_name = ?"
    iswork = cursor.execute(query, (competitor, work_id, contest_name)).fetchone()

    if iswork:
        conn.close()
        return jsonify({"error":"Book already read, this should not occur"}), 500 #INTERNAL SERVER ERROR
    
    query = "INSERT INTO contest_books_read (username, contest_name, work_id) VALUES (?, ?)"
    try:
        cursor.execute(query, (competitor, contest_name, work_id))
    except sqlite3.Error as e:
        print("PROBLEM: " + str(e))
        return jsonify({"error":f"{e}"}), 500 #INTERNAL SERVER ERROR
    
    conn.close()
    return jsonify({"message":f"Work {work_id} marked as done"}), 200 #OK

#@CONTESTS GET CONTESTS LIST
# Gen. AI was used to format the date parameter correctly.
@app.route("/contest/info", methods=["GET"])
def get_contests():
    conn = db_connect()
    cursor = conn.cursor()
    
    query = "SELECT * FROM contests"
    contest_names = cursor.execute(query).fetchall()
    
    contest_list = []
    
    for contest_elem in contest_names:
        query = "SELECT username FROM contest_participants WHERE perm_lvl = 0 AND contest_name = ?"
        try:
            cursor.execute(query, (contest_elem[0],))
            organizer_row = cursor.fetchone()
            organizer = organizer_row[0] if organizer_row else ""
        except sqlite3.Error as e:
            return jsonify({"error":f"sqlite3err {e} QUERY {query}"}), 500 # INTERNAL SERVER ERROR

        # Ensure date is returned as ISO string (for JS Date parsing)
        end_date = contest_elem[2]
        end_date = end_date.format()

        contest_json = {
            "contest_name": contest_elem[0],
            "book_count": contest_elem[1],
            "end_date": end_date,
            "organizer": organizer
        }

        contest_list.append(contest_json)
    conn.close()
    return jsonify(contest_list), 200 # OK

#@CONTESTS GET CONTEST BOOKS
@app.route("/contest/<string:contest_name>/books", methods=["GET"])
def get_books(contest_name):
    
    if not contest_name:
        return jsonify({"error":"Missing contest_name"}), 400 #INVALID REQUEST
    
    conn = db_connect()
    cursor = conn.cursor()
    
    try:
        query = "SELECT work_id FROM contest_books WHERE contest_name = ?"
        works = cursor.execute(query, (contest_name,))
    except sqlite3.Error as e:
        return jsonify({"error":f"sqlite3err {e}"}), 500 # INTERNAL SERVER ERROR
    book_list = []
    for work in works:
        book = get_book(work[0])
        book_list.append(book)
        
    conn.close()
    return jsonify(book_list), 200 # OK

#@CONTEST GET PARTICIPANTS
@app.route("/contest/<string:contest_name>/participants", methods=["GET"])
def get_participants(contest_name):
    
    if not contest_name:
        return jsonify({"error":"Missing contest_name"}), 400 #INVALID REQUEST
    
    conn = db_connect()
    cursor = conn.cursor()
    
    try:
        query = "SELECT username FROM contest_participants WHERE contest_name = ?"
        all_participants = cursor.execute(query, (contest_name,))
    except sqlite3.Error as e:
        return jsonify({"error":f"sqlite3err {e}"}), 500 # INTERNAL SERVER ERROR
    
    participant_list = []
    for participant in all_participants:
        work_list = []
        try:
            query = "SELECT work_id FROM contest_books_read WHERE username = ? AND contest_name = ?"
            works = cursor.execute(query, (participant[0], contest_name,))
        except sqlite3.Error as e:
            return jsonify({"error":f"sqlite3err {e}"}), 500 # INTERNAL SERVER ERROR
        
        for work in works:
            work_list.append(get_book(work[0]))
            
        participant = {
            "username" : participant[0],
            "completed_books" : work_list
        }
        participant_list.append(participant)
    
    conn.close()
    return jsonify(participant_list), 200 # OK

def fetch_users(searchTerm):
    conn = db_connect()
    cursor = conn.cursor()

    cursor.execute("SELECT username, first_name, last_name FROM users where username OR first_name OR last_name LIKE (?)", (("%" + searchTerm + "%"),))

    rows = cursor.fetchall()
    columns = [description[0] for description in cursor.description]
    users = [dict(zip(columns, row)) for row in rows]

    conn.close()
    return users


def fetch_reviews(searchTerm):
    conn = db_connect()
    cursor = conn.cursor()

    cursor.execute("SELECT * FROM reviews where review_text LIKE (?)", (("%" + searchTerm + "%"),))

    rows = cursor.fetchall()
    print(rows)
    columns = [description[0] for description in cursor.description]
    reviews = [dict(zip(columns, row)) for row in rows]

    conn.close()
    print("RESULTS " , reviews)
    return reviews

def fetch_contests(searchTerm):
    conn = db_connect()
    cursor = conn.cursor()


    search_result = conn.execute("SELECT * FROM contests WHERE contests.contest_name LIKE (?)", (searchTerm,)).fetchall()

    # query = "SELECT * FROM contests WHERE contests.book_count = search"
    # if query:
    #     cursor = conn.execute(query, (query))
    # query = "SELECT * FROM contests WHERE contests.end_date = search"
    # if query:
    #     cursor = conn.execute(query, (search,))
    # rows = cursor.fetchall()
    # columns = [description[0] for description in cursor.description]
    # competitions = [dict(zip(columns, row)) for row in rows]
    conn.close()

    if search_result:
        return jsonify(search_result)
    else:
        return jsonify([])












# Creates an empty shelf from a new name
# Returns an error if a shelf with that name already exists
@app.route("/shelf", methods=['POST'])
@jwt_required()
def create_shelf():
    current_user = get_jwt_identity()
    token = request.headers.get("Authorization")

    shelf_name = request.json.get("shelfName")
    print(request.json)

    if not token:
        return jsonify({"error": "Missing authorization token"}), 401

    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT username FROM users WHERE username = ?"
    user_row = cursor.execute(find_user_query, (current_user,)).fetchone()
    user = user_row["username"]

    if not user:
        conn.close()
        return jsonify({"error":f"user {current_user} not found, no shelf update"}), 404 #BAD REQUEST

    find_shelf_query = "SELECT shelf_name FROM user_shelves WHERE username = ? AND shelf_name = ?"
    shelf = cursor.execute(find_shelf_query, (current_user, shelf_name)).fetchone()

    if shelf:
        conn.close()
        return jsonify({"error":f"shelf {shelf_name} already exists, no addition"}), 400 #BAD REQUEST 

    try:
        query = f"INSERT INTO user_shelves (username, shelf_name) VALUES (?, ?)"
        cursor.execute(query, (current_user, shelf_name))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR

    conn.close()
    return jsonify({"message": "New shelf created successfully", "user_id" : current_user, "shelf name" : shelf_name}), 201 #CREATED




# add a book to a user's shelf
## CHANGED - post methods require data sent in the request itself
@app.route("/shelf/<string:shelf_name>", methods=['POST'])
@jwt_required()
def shelve_book(shelf_name):
    current_user = get_jwt_identity()
    token = request.headers.get("Authorization")
    work_id = request.json.get("work_id")


    if not token:
        return jsonify({"error": "Missing authorization token"}), 401

    conn = db_connect()
    cursor = conn.cursor()

    find_user_query = "SELECT DISTINCT(shelf_name) FROM user_shelves WHERE username = ? AND shelf_name = ?"
    shelf = cursor.execute(find_user_query, (current_user, shelf_name,))

    if not shelf:
        conn.close()
        return jsonify({"error":f"user or shelf {current_user} not found, not updating either"}), 400 #BAD REQUEST 

    try:
        query = f"INSERT INTO shelved_books (username, work_id, shelf_name) VALUES (?, ?, ?)"
        cursor.execute(query, (current_user, work_id, shelf_name))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR

    conn.close()
    return jsonify({"message": "Book shelved successfully", "user_id" : current_user, "work_ID" : work_id, "shelf name" : shelf_name}), 201 #CREATED


# delete a specific book from a user's shelf
@app.route("/shelf/<string:shelf_name>/<string:work_id>", methods=['DELETE'])
@jwt_required()
def unshelve_book(shelf_name, work_id):
    current_user = get_jwt_identity()
    token = request.headers.get("Authorization")

    if not token:
        return jsonify({"error": "Missing authorization token"}), 401
    
    print(request)

    conn = db_connect()
    cursor = conn.cursor()


    find_shelf_book = "SELECT work_id FROM shelved_books WHERE username = ? AND shelf_name = ? AND work_id = ?"
    shelved_book = cursor.execute(find_shelf_book, (current_user, shelf_name, work_id))

    if not shelved_book:
        conn.close()
        return jsonify({"error":f"book {work_id} not found in shelf {shelf_name} belonging to {current_user}"}), 400 #BAD REQUEST 
    
    try:
        query = "DELETE FROM shelved_books WHERE username = ? AND shelf_name = ? AND work_id = ?"
        cursor.execute(query, (current_user, shelf_name, work_id))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR

    conn.close()
    return jsonify({"message": "Book unshelved successfully", "user_id" : current_user, "shelf name" : shelf_name, "work_ID" : work_id}), 200 #OK


# delete an entire shelf
@app.route("/shelf/<string:shelf_name>", methods=['DELETE'])
@jwt_required()
def delete_shelf(shelf_name):
    current_user = get_jwt_identity()
    token = request.headers.get("Authorization")

    if not token:
        return jsonify({"error": "Missing authorization token"}), 401

    conn = db_connect()
    cursor = conn.cursor()

    find_shelf = "SELECT shelf_name FROM user_shelves WHERE username = ? AND shelf_name = ?"
    shelf = cursor.execute(find_shelf, (current_user, shelf_name)).fetchone()

    if not shelf:
        conn.close()
        return jsonify({"error":f"shelf with name {shelf_name} not found. no action taken."}), 400 #BAD REQUEST 

    try:
        query = f"DELETE FROM shelved_books WHERE username = ? AND shelf_name = ?"
        cursor.execute(query, (current_user, shelf_name))
        query = f"DELETE FROM user_shelves WHERE username = ? AND shelf_name = ?"
        cursor.execute(query, (current_user, shelf_name))
        conn.commit()
    except sqlite3.Error as error:
        return jsonify({"error": "SQLITE3 ERROR!: " + str(error)}), 500 #INTERNAL SERVER ERROR

    conn.close()
    return jsonify({"message": "Shelf deleted successfully", "user_id" : current_user, "shelf name" : shelf_name}), 200 #OK


# Get all books in current user's specific shelf
@app.route("/shelf/<string:username>/<string:shelf_name>", methods=['GET'])
def get_shelf(username, shelf_name):
    current_user = username

    conn = db_connect()
    cursor = conn.cursor()

    find_shelf = "SELECT shelf_name FROM user_shelves WHERE username = ? AND shelf_name = ?"
    shelf = cursor.execute(find_shelf, (current_user, shelf_name)).fetchone()

    if not shelf:
        conn.close()
        return jsonify({"error":f"shelf with name {shelf_name} not found. no action taken."}), 400 #BAD REQUEST 

    query = "SELECT work_id FROM shelved_books WHERE username = ? AND shelf_name = ?"
    cursor.execute(query, (current_user, shelf_name))
    books = cursor.fetchall()
    columns = [description[0] for description in cursor.description]
    zipped_books = [dict(zip(columns, book)) for book in books]

    # NOTE : circular logic. you're using the input
    final = []
    final += [{"books" : zipped_books}]

    conn.close()
    print("final" , final)
    ## ERROR - saying final is not JSON serializable. Also not returning book items, only returns 
    #work id's in a list
    if final:
        return jsonify(final)


@app.route("/shelf/<string:username>", methods=['GET'])
def get_user_shelves(username):
    current_user = username

    conn = db_connect()
    cursor = conn.cursor()

    query = "SELECT shelf_name FROM user_shelves WHERE username = ?"
    cursor.execute(query, (current_user,))
    shelves = cursor.fetchall()
    columns = [description[0] for description in cursor.description]
    zipped_shelves = [dict(zip(columns, shelf)) for shelf in shelves]

    conn.close()
    print(zipped_shelves)

    return jsonify(zipped_shelves)


if __name__ == '__main__':
    app.run(host="0.0.0.0", debug=True, port=5000)